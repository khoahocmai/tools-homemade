<!doctype html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Pretty JSON</title>
    <style>
        :root {
            --bg: #0a1326;
            --panel: #0f254a;
            --muted: #9aa4b2;
            --text: #bfe0ff;
            --accent: #1f72ff;
            --accent2: #4fff77;
            --warn: #ff6b6b;
            --danger: #ff1a1a;
            --mono: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            --pad: 14px;
            --border: rgba(255, 255, 255, .08);
            --border-hover: rgba(255, 255, 255, .16);
            --val-str: #ffd59e;
            --val-num: #b4ffb4;
            --val-bool: #ffb3c7;
            --val-null: #aaa;
        }

        [data-theme="light"] {
            --bg: #f0f0f0;
            --panel: #f1f3f4;
            --muted: #777;
            --text: #333;
            --accent: #1f72ff;
            --accent2: #4fff77;
            --warn: #ff6b6b;
            --danger: #ff1a1a;
            --border: rgba(0, 0, 0, .12);
            --border-hover: rgba(0, 0, 0, .24);
            --input-bg: #f1f3f4;
            --pill-bg: #e8f4fd;
            --pill-text: #1f72ff;
            --search-bg: #f1f3f4;
            --val-str: #b8860b;
            --val-num: #51ad51;
            --val-bool: #c95d7a;
            --val-null: #615e5e;
        }

        [data-theme="dark"] {
            --border: rgba(255, 255, 255, .08);
            --border-hover: rgba(255, 255, 255, .16);
            --input-bg: #0c172c;
            --pill-bg: #0e2247;
            --pill-text: #bfe0ff;
            --search-bg: #0c172c;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font: 16px/1.5 Inter, system-ui, Segoe UI, Roboto, sans-serif;
            transition: background .3s, color .3s;
        }

        /* Header */
        header {
            position: sticky;
            top: 0;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 14px;
            padding: 12px var(--pad);
            background: var(--panel);
            border-bottom: 1px solid var(--border);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 800;
        }

        .brand .logo {
            font-size: 20px;
        }

        .brand .title {
            font-size: 16px;
            letter-spacing: .3px;
        }

        /* Buttons */
        button,
        label.button {
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            padding: 9px 14px;
            transition: .2s;
        }

        button:hover,
        label.button:hover {
            filter: brightness(1.08);
        }

        .btn-mini {
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 10px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .controls button {
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: 600;
            background: var(--panel);
            color: var(--text);
        }

        .controls button:hover {
            border-color: var(--border-hover);
            filter: brightness(1.1);
        }

        .controls input[type=file] {
            display: none !important;
        }

        /* Layout */
        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            padding: 14px;
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (max-width:1100px) {
            .row {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .25);
            overflow: hidden;
        }

        .panel h2 {
            margin: 0;
            padding: 10px var(--pad);
            font-size: 13px;
            text-transform: uppercase;
            color: var(--muted);
            border-bottom: 1px solid var(--border);
        }

        .body {
            padding: var(--pad);
            position: relative;
        }

        .small {
            font-size: 12px;
            color: var(--muted);
        }

        /* Inputs & code */
        textarea,
        pre {
            width: 100%;
            background: var(--input-bg, var(--panel));
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 12px;
            font-family: var(--mono);
        }

        textarea {
            min-height: 340px;
            padding: 12px;
            resize: vertical;
        }

        pre {
            padding: 10px;
            max-height: 380px;
            overflow: auto;
            font-size: 14px;
            margin-top: 8px;
        }

        /* Pills */
        .pills {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 8px 0;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: var(--pill-bg, var(--panel));
            border: 1px solid var(--border);
            color: var(--pill-text, var(--text));
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
        }

        .pill.key-pill {
            cursor: pointer;
            margin: 3px 6px;
            transition: background .2s;
        }

        .pill.key-pill:hover {
            background: var(--border-hover);
        }

        .pill.hide {
            display: none;
        }

        /* Tree */
        .tree {
            font-family: var(--mono);
            font-size: 14px;
        }

        .node {
            margin-left: 18px;
            border-left: 1px dashed var(--border);
            padding-left: 10px;
        }

        .node.root {
            margin-left: 0;
            border-left: none;
            padding-left: 0;
        }

        .line {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .caret {
            width: 18px;
            height: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-hover);
            border-radius: 6px;
            background: var(--panel);
            cursor: pointer;
            font-size: 13px;
            font-weight: 700;
            color: var(--text);
        }

        .caret.disabled {
            visibility: hidden;
        }

        .key {
            color: #a3d0ff;
        }

        .type {
            color: #9bd8c1;
        }

        .val-str {
            color: var(--val-str);
        }

        .val-num {
            color: var(--val-num);
        }

        .val-bool {
            color: var(--val-bool);
        }

        .val-null {
            color: var(--val-null);
        }

        .hidden {
            display: none;
        }

        .err {
            color: var(--danger);
            font-weight: 600;
        }

        .line.hit {
            background: linear-gradient(90deg, rgba(255, 213, 102, .35), rgba(255, 213, 102, .10));
            box-shadow: inset 3px 0 0 var(--warn);
            border-radius: 8px;
            border-left: none;
            padding-left: 0;
        }

        .line.hit-focus {
            outline: 2px solid var(--accent);
            border-radius: 8px;
            box-shadow: 0 0 0 3px rgba(120, 183, 255, .25) inset;
        }

        mark.mark {
            background: var(--warn);
            color: #0b1220;
            border-radius: 4px;
            padding: 0 2px;
            box-shadow: 0 0 0 2px rgba(255, 213, 102, .25);
        }

        .node.selected-subtree {
            outline: 2px solid var(--accent2);
            outline-offset: 4px;
            border-radius: 12px;
            background: rgba(155, 255, 209, .05);
        }

        .line.selected {
            background: rgba(155, 255, 209, .10);
        }

        /* Search bar */
        .bar {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .bar.sticky {
            position: sticky;
            top: calc(var(--headerH, 0px)+8px);
            z-index: 15;
            margin: calc(-1*var(--pad)) calc(-1*var(--pad)) 10px;
            padding: 12px 14px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, .45);
        }

        .searchWrap {
            position: relative;
            flex: 1;
        }

        .search {
            width: 100%;
            min-width: 160px;
            background: var(--search-bg, var(--panel));
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 40px 10px 12px;
            color: var(--text);
        }

        .clear-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 26px;
            height: 26px;
            display: none;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #1a2b4d;
            color: #cde1ff;
            cursor: pointer;
            font-weight: 800;
        }

        .clear-btn.show {
            display: flex;
        }

        /* Cards */
        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
        }

        .card header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: transparent;
            border: none;
            padding: 0;
            margin-bottom: 8px;
        }

        .list {
            max-height: 180px;
            overflow: auto;
            font-family: var(--mono);
            font-size: 13px;
            line-height: 1.6;
        }

        .kitem {
            display: block;
            padding: 2px 0;
            cursor: pointer;
            color: var(--accent);
        }

        .kitem:hover {
            text-decoration: none;
        }

        /* Value grids */
        .values-grid {
            display: grid;
            grid-template-areas:
                "bool null"
                "str num";
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        @media (max-width:900px) {
            .values-grid {
                grid-template-areas: "bool" "null" "str" "num";
                grid-template-columns: 1fr;
            }
        }

        .valcol {
            background: var(--input-bg, var(--panel));
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
        }

        .valcol-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            color: var(--muted);
            font-weight: 700;
        }

        .valcol.bool {
            grid-area: bool;
        }

        .valcol.null {
            grid-area: null;
        }

        .valcol.string {
            grid-area: str;
        }

        .valcol.number {
            grid-area: num;
        }

        .valcol.mini .val-list {
            max-height: 76px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-content: flex-start;
        }

        .tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border: 1px solid var(--border);
            border-radius: 999px;
            cursor: pointer;
            font-family: var(--mono);
        }

        .tag:hover {
            filter: brightness(1.08);
        }

        .val-list {
            max-height: 210px;
            overflow-y: auto;
            overflow-x: hidden;
            font-family: var(--mono);
            font-size: 13px;
            line-height: 1.6;
        }

        .val-item {
            display: block;
            overflow-wrap: anywhere;
            word-break: break-word;
            cursor: pointer;
        }

        .val-item.string {
            color: var(--val-str);
        }

        .val-item.number {
            color: var(--val-num);
        }

        .val-item.boolean {
            color: var(--val-bool);
        }

        .val-item.null {
            color: var(--val-null);
        }

        /* Diff colors */
        .diff-add {
            color: #9bffd1;
        }

        .diff-del {
            color: #ff9b9b;
        }

        .diff-chg {
            color: #ffd166;
        }

        /* Search option mini buttons */
        .searchOptions {
            display: flex;
            gap: 4px;
        }

        .searchOptions .btn-mini {
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid var(--border);
            background: var(--panel);
            color: var(--text);
            transition: .2s;
        }

        .searchOptions .btn-mini.active {
            background: var(--accent);
            color: #fff;
        }

        /* Light theme overrides */
        [data-theme="light"] {
            --type-color: #12b62d;
        }

        [data-theme="light"] .key {
            color: #1e3a8a;
        }

        [data-theme="light"] .type {
            color: var(--type-color);
            font-weight: 600;
        }

        [data-theme="light"] .val-item.string {
            color: #b8860b;
        }

        [data-theme="light"] .val-item.number {
            color: #006400;
        }

        [data-theme="light"] .val-item.boolean {
            color: #b22222;
        }

        [data-theme="light"] .val-item.null {
            color: #444;
        }

        [data-theme="light"] .tag.boolean {
            color: #b22222;
        }

        [data-theme="light"] .tag.null {
            color: #444;
        }

        /* Button gradients by theme */
        [data-theme="dark"] button,
        [data-theme="dark"] label.button {
            background: linear-gradient(180deg, #1f3d6b, #13315c);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, .14);
        }

        [data-theme="light"] button,
        [data-theme="light"] label.button {
            background: #e8f4fd;
            color: #1f72ff;
            border: 1px solid var(--border);
        }

        .search-float {
            position: fixed;
            right: 18px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 9999;
            display: none;

            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(15, 28, 55, .92);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 10px;
            box-shadow: 0 10px 28px rgba(0, 0, 0, .35);
        }

        /* handle */
        .float-handle {
            width: 46px;
            height: 46px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(255, 255, 255, .06);
            color: #d7e7ff;
            cursor: pointer;
        }

        /* body layout 2 d√≤ng */
        .float-body {
            display: grid;
            gap: 10px;
            width: 260px;
        }

        .float-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .float-row-2 {
            justify-content: space-between;
        }

        /* input */
        .search-float input.search {
            flex: 1;
            border-radius: 12px;
            padding: 9px 10px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(255, 255, 255, .04);
            color: #d7e7ff;
            outline: none;
        }

        /* row 2 parts */
        .searchOptions {
            display: flex;
            gap: 8px;
        }

        .float-nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .search-float .badge {
            min-width: 86px;
            height: 36px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(255, 255, 255, .04);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: #d7e7ff;
        }

        /* ====== COLLAPSE/EXPAND RULES ====== */

        /* collapsed: ch·ªâ hi·ªán handle */
        .search-float.is-collapsed .float-body {
            display: none;
        }

        .search-float.is-collapsed .float-handle {
            display: block;
        }

        /* expanded: ·∫©n handle (ƒë√∫ng y√™u c·∫ßu c·ªßa b·∫°n) */
        .search-float.is-expanded .float-handle {
            display: none;
        }

        .search-float.is-expanded .float-body {
            display: grid;
        }

        .float-row-input {
            position: relative;
            display: flex;
            align-items: center;
        }

        .float-row-input input.search {
            width: 100%;
            padding-right: 44px;
        }

        .float-row-input .clear-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 28px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(255, 255, 255, .06);
            color: #d7e7ff;
            display: grid;
            place-items: center;
            cursor: pointer;
        }

        .float-row-input .clear-btn,
        #btnClearSearch2.clear-btn {
            padding: 0;
            line-height: 1;
            font-size: 18px;
        }

        #btnClearSearch2.clear-btn {
            display: grid;
            place-items: center;
        }
    </style>
</head>

<body>
    <header>
        <div class="brand" id="brand">
            <span class="logo">üß©</span><span class="title">Pretty JSON</span>
        </div>
        <div class="controls">
            <button id="btnToggleTheme" class="btn-mini">üåô</button>
            <label class="button" for="fileInput">üìÑ M·ªü file</label>
            <input id="fileInput" type="file" accept=".json,.txt,.log,.js,.jsonc" />
            <button id="btnSample">D√°n v√≠ d·ª•</button>
            <button id="btnCopy">üìã Copy</button>
            <button id="btnToggleAll">‚§° Collapse all</button>
            <button id="btnToggleQuotes" class="btn-mini">üî§ B·ªè " " field</button>
            <button id="btnSortAZ">üî† Sort A‚ÄìZ</button>
            <button id="btnDownload">‚¨áÔ∏è T·∫£i JSON</button>
            <button id="btnClear">üßπ Xo√°</button>
        </div>
    </header>

    <!-- H√†ng 1: Input + K·∫øt qu·∫£ -->
    <div class="row">
        <section class="panel">
            <h2>ƒê·∫ßu v√†o</h2>
            <div class="body">
                <textarea id="input"
                    placeholder='D√°n JSON/JSON5/Object literal v√†o ƒë√¢y...'>{ "field-1": "value-1", "field-2": 200, "array-1": [ { "array-field-1": "a", "array-field-2": 1 }, { "array-field-1": "b", "array-field-2": 2 }, { "array-field-1": "c", "array-field-2": 3, "emptyArr": [], "emptyObj": {} } ], "object-1": { "field-1a": true, "field-1b": null, "emptyArr": [], "emptyObj": {}, "nested": { "deeperEmptyArr": [], "deeperEmptyObj": {} } }, "emptyArrayTop": [], "emptyObjectTop": {} }</textarea>
                <div class="small" id="meta"></div>
                <h3 class="small" style="margin:14px 0 6px;color:var(--muted)">JSON (ƒë√£ format)</h3>
                <pre id="pretty"></pre>
            </div>
        </section>

        <section class="panel result-panel">
            <h2>K·∫øt qu·∫£</h2>
            <div class="body">
                <div class="bar sticky" id="resultSearchBar">
                    <div class="searchWrap">
                        <input id="search" type="text" placeholder="üîé T√¨m kh√≥a/gi√° tr·ªã" class="search" />
                        <button id="btnClearSearch" class="clear-btn" title="Xo√° t√¨m ki·∫øm">√ó</button>
                    </div>
                    <div class="searchOptions">
                        <button class="btn-mini" id="optCase">Aa</button>
                        <button class="btn-mini" id="optWhole">üîç</button>
                    </div>

                    <span class="pill hide" id="resultCount"></span>
                    <span class="pill hide" id="err"></span>
                    <span class="pill hide" id="childInfo"></span>
                    <div id="navHits" style="margin-left:auto; display:none; gap:8px; align-items:center">
                        <button id="btnPrevHit" class="btn-mini">‚Üê</button>
                        <button id="btnNextHit" class="btn-mini">‚Üí</button>
                    </div>
                </div>
                <div id="tree" class="tree"></div>
            </div>
        </section>
    </div>

    <!-- H√†ng 2: Th·ªëng k√™ + Tr√≠ch xu·∫•t -->
    <div class="row" style="grid-template-columns: 1fr;">
        <section class="panel">
            <h2>T·ªïng quan & Tr√≠ch xu·∫•t</h2>
            <div class="body">
                <div class="pills" id="statsPills"></div>

                <div class="card" style="margin-top:8px">
                    <header>
                        <strong>Key kh√¥ng c√≥ gi√° tr·ªã con</strong>
                    </header>
                    <div class="list" id="keysList"></div>
                </div>

                <div class="card" style="margin-top:8px">
                    <header>
                        <strong>Gi√° tr·ªã theo lo·∫°i</strong>
                    </header>

                    <div class="values-grid">
                        <!-- Tr√™n: Boolean -->
                        <div class="valcol mini bool">
                            <div class="valcol-head"><span id="headBool">Boolean</span></div>
                            <div class="val-list" id="listBooleans"></div>
                        </div>

                        <!-- Tr√™n: Null -->
                        <div class="valcol mini null">
                            <div class="valcol-head"><span id="headNull">Null</span></div>
                            <div class="val-list" id="listNulls"></div>
                        </div>

                        <!-- D∆∞·ªõi: String -->
                        <div class="valcol string">
                            <div class="valcol-head">
                                <span id="headString">String</span>
                            </div>
                            <div class="val-list" id="listStrings"></div>
                        </div>

                        <!-- D∆∞·ªõi: Number -->
                        <div class="valcol number">
                            <div class="valcol-head">
                                <span id="headNumber">Number</span>
                            </div>
                            <div class="val-list" id="listNumbers"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <div id="searchFloat" class="search-float is-collapsed" aria-hidden="true">

        <!-- CH·ªà HI·ªÜN KHI COLLAPSED -->
        <button id="floatHandle" class="float-handle" title="T√¨m ki·∫øm">üîé</button>

        <!-- CH·ªà HI·ªÜN KHI EXPANDED -->
        <div class="float-body">
            <!-- D√≤ng 1 -->
            <div class="float-row float-row-input">
                <input id="search2" type="text" placeholder="T√¨m..." class="search" />
                <button id="btnClearSearch2" class="clear-btn" title="Xo√°">√ó</button>
            </div>

            <!-- D√≤ng 2 -->
            <div class="float-row float-row-2">
                <div class="searchOptions">
                    <button class="btn-mini" id="optCase2">Aa</button>
                    <button class="btn-mini" id="optWhole2">üîç</button>
                </div>

                <div class="float-nav">
                    <button class="btn" id="floatPrev" title="K·∫øt qu·∫£ tr∆∞·ªõc">‚Üë</button>
                    <div class="badge" id="floatCounter">0/0</div>
                    <button class="btn" id="floatNext" title="K·∫øt qu·∫£ ti·∫øp">‚Üì</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* ===== Helpers ===== */
        const $ = s => document.querySelector(s);
        const input = $('#input'),
            tree = $('#tree'),
            pretty = $('#pretty');
        const meta = $('#meta'),
            rc = $('#resultCount'),
            err = $('#err'),
            childInfo = $('#childInfo');
        const search = $('#search'),
            search2 = $('#search2'),
            btnClearSearch = $('#btnClearSearch'),
            btnClearSearch2 = $('#btnClearSearch2');
        let searchHits = [];
        let currentHitIndex = -1;


        const statsPills = $('#statsPills'), keysList = $('#keysList'),
            listStrings = $('#listStrings'), listNumbers = $('#listNumbers'),
            listBooleans = $('#listBooleans'), listNulls = $('#listNulls');

        const btnToggleTheme = document.getElementById('btnToggleTheme');
        btnToggleTheme.addEventListener('click', () => {
            const currentTheme = document.body.getAttribute('data-theme');
            if (currentTheme === 'light') {
                document.body.setAttribute('data-theme', 'dark');
                btnToggleTheme.textContent = 'üåô'; // ƒê·ªïi bi·ªÉu t∆∞·ª£ng th√†nh m·∫∑t trƒÉng khi ·ªü ch·∫ø ƒë·ªô s√°ng
            } else {
                document.body.setAttribute('data-theme', 'light');
                btnToggleTheme.textContent = 'üåû'; // ƒê·ªïi bi·ªÉu t∆∞·ª£ng th√†nh m·∫∑t tr·ªùi khi ·ªü ch·∫ø ƒë·ªô t·ªëi
            }
        });

        function debounce(fn, ms = 200) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }
        function escapeHtml(s) { return String(s).replace(/[&<>"]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[c])) }
        function typeOf(v) { if (v === null) return 'null'; if (Array.isArray(v)) return 'array'; return typeof v; }
        function setPill(el, txt) { el.textContent = txt || ''; el.classList.toggle('hide', !txt); }
        function toggleClearSearch() { btnClearSearch.classList.toggle('show', !!(search?.value || '').trim()); }
        function toggleClearSearch2() { btnClearSearch2.classList.toggle('show', !!(search2?.value || '').trim()); }
        function copyText(t) { navigator.clipboard.writeText(t); }

        /* ===== Preprocess: comments, trailing commas, quote keys, expand shorthand ===== */
        function stripComments(src) {
            let out = '', i = 0, inStr = false, esc = false, inSL = false, inML = false;
            while (i < src.length) {
                const ch = src[i], nxt = src[i + 1];
                if (inSL) { if (ch === '\n') { inSL = false; out += '\n'; } i++; continue; }
                if (inML) { if (ch === '*' && nxt === '/') { inML = false; inML = false; i += 2; continue; } i++; continue; }
                if (inStr) { out += ch; if (esc) esc = false; else if (ch === '\\') esc = true; else if (ch === '"') inStr = false; i++; continue; }
                if (ch === '"') { inStr = true; out += ch; i++; continue; }
                if (ch === '/' && nxt === '/') { inSL = true; i += 2; continue; }
                if (ch === '/' && nxt === '*') { inML = true; i += 2; continue; }
                out += ch; i++;
            }
            return out;
        }
        function stripTrailingCommas(src) {
            let out = '', i = 0, inStr = false, esc = false;
            while (i < src.length) {
                const ch = src[i];
                if (inStr) { out += ch; if (esc) esc = false; else if (ch === '\\') esc = true; else if (ch === '"') inStr = false; i++; continue; }
                if (ch === '"') { inStr = true; out += ch; i++; continue; }
                if (ch === ',') { let j = i + 1; while (j < src.length && /\s/.test(src[j])) j++; if (src[j] === '}' || src[j] === ']') { i++; continue; } }
                out += ch; i++;
            }
            return out;
        }
        function replaceUndefined(src) {
            let out = '', i = 0, inStr = false, esc = false;
            while (i < src.length) {
                const ch = src[i];
                if (inStr) { out += ch; if (esc) esc = false; else if (ch === '\\') esc = true; else if (ch === '"') inStr = false; i++; continue; }
                if (ch === '"') { inStr = true; out += ch; i++; continue; }
                if (src.slice(i, i + 9) === 'undefined' &&
                    !/[A-Za-z0-9_$]/.test(src[i - 1] || '') &&
                    !/[A-Za-z0-9_$]/.test(src[i + 9] || '')) {
                    out += 'null'; i += 9; continue;
                }
                out += ch; i++;
            }
            return out;
        }
        function quoteKeysAndExpandShorthand(src) {
            let out = '', i = 0, inStr = false, esc = false;
            const stack = []; // '{' ho·∫∑c '['

            while (i < src.length) {
                const ch = src[i];
                // trong string
                if (inStr) {
                    out += ch;
                    if (esc) esc = false;
                    else if (ch === '\\') esc = true;
                    else if (ch === '"') inStr = false;
                    i++;
                    continue;
                }
                // m·ªü string
                if (ch === '"') {
                    inStr = true;
                    out += ch;
                    i++;
                    continue;
                }

                // tracking context
                if (ch === '{' || ch === '[') { stack.push(ch); out += ch; i++; continue; }
                if (ch === '}' || ch === ']') { stack.pop(); out += ch; i++; continue; }

                const inObject = stack.length && stack[stack.length - 1] === '{';

                if (inObject && (ch === '{' || ch === ',')) {
                    out += ch; i++;
                    while (i < src.length && /\s/.test(src[i])) { out += src[i++]; }

                    // Tr∆∞·ªùng h·ª£p: key c√≥ quote
                    if (src[i] === '"') {
                        const m = /^"([^"]+)"/.exec(src.slice(i));
                        if (m) {
                            const name = m[1];
                            let j = i + m[0].length;
                            while (j < src.length && /\s/.test(src[j])) j++;

                            // Tr∆∞·ªùng h·ª£p: "field-1" ‚Üí thi·∫øu d·∫•u :
                            if (src[j] === ',' || src[j] === '}') {
                                out += `"${name}": null`;
                                i = j;
                                continue;
                            }

                            // Tr∆∞·ªùng h·ª£p: "field-1": nh∆∞ng thi·∫øu value
                            if (src[j] === ':') {
                                out += `"${name}":`;
                                j++;
                                while (j < src.length && /\s/.test(src[j])) j++;
                                if (src[j] === ',' || src[j] === '}') {
                                    out += ' null';
                                    i = j;
                                    continue;
                                }
                                i = j;
                                continue;
                            }
                        }
                    }

                    // Tr∆∞·ªùng h·ª£p: field-1 (kh√¥ng quote)
                    const m = /^[A-Za-z_$][\w$-]*/.exec(src.slice(i));
                    if (m) {
                        const name = m[0];
                        let j = i + name.length, buf = '';
                        while (j < src.length && /\s/.test(src[j])) buf += src[j++];

                        // Tr∆∞·ªùng h·ª£p: field-1 ‚Üí thi·∫øu value
                        if (src[j] === ',' || src[j] === '}') {
                            out += `"${name}": null`;
                            i = j;
                            continue;
                        }

                        // Tr∆∞·ªùng h·ª£p: field-1: nh∆∞ng thi·∫øu value
                        if (src[j] === ':') {
                            out += `"${name}"${buf}:`;
                            j++;
                            while (j < src.length && /\s/.test(src[j])) j++;
                            if (src[j] === ',' || src[j] === '}') {
                                out += ' null';
                                i = j;
                                continue;
                            }
                            i = j;
                            continue;
                        }
                    }
                    continue;
                }
                out += ch; i++;
            }
            return out;
        }
        function handleEllipsis(src) {
            let out = '', i = 0, inStr = false, esc = false;
            while (i < src.length) {
                const ch = src[i];
                if (inStr) { out += ch; if (esc) esc = false; else if (ch === '\\') esc = true; else if (ch === '"') inStr = false; i++; continue; }
                if (ch === '"') { inStr = true; out += ch; i++; continue; }

                // [ ... ]  -> []
                if (ch === '[') {
                    let j = i + 1;
                    while (j < src.length && /\s/.test(src[j])) j++;
                    if (src.slice(j, j + 3) === '...') {
                        j += 3;
                        while (j < src.length && /\s/.test(src[j])) j++;
                        if (src[j] === ']') { out += '[]'; i = j + 1; continue; }
                    }
                }

                // { ... } -> {}
                if (ch === '{') {
                    let j = i + 1;
                    while (j < src.length && /\s/.test(src[j])) j++;
                    if (src.slice(j, j + 3) === '...') {
                        j += 3;
                        while (j < src.length && /\s/.test(src[j])) j++;
                        if (src[j] === '}') { out += '{}'; i = j + 1; continue; }
                    }
                }

                // ... -> null (ƒë·ª©ng m·ªôt m√¨nh)
                if (src.slice(i, i + 3) === '...') { out += 'null'; i += 3; continue; }

                out += ch; i++;
            }
            return out;
        }
        function fixInvalidEscapes(src) {
            let out = '', i = 0, inStr = false, esc = false;
            while (i < src.length) {
                const ch = src[i];

                if (!inStr) {
                    if (ch === '"') { inStr = true; out += ch; i++; continue; }
                    out += ch; i++; continue;
                }

                // ƒëang ·ªü trong chu·ªói
                if (!esc) {
                    if (ch === '\\') { esc = true; i++; continue; }
                    if (ch === '"') { inStr = false; out += ch; i++; continue; }
                    out += ch; i++; continue;
                }

                // sau d·∫•u backslash
                const n = src[i];

                // escape h·ª£p l·ªá c·ªßa JSON
                if (n === '"' || n === '\\' || n === '/' ||
                    n === 'b' || n === 'f' || n === 'n' || n === 'r' || n === 't') {
                    out += '\\' + n; i++; esc = false; continue;
                }

                // \uXXXX h·ª£p l·ªá
                if (n === 'u' && /^[0-9a-fA-F]{4}/.test(src.slice(i + 1, i + 5))) {
                    out += '\\u' + src.slice(i + 1, i + 5);
                    i += 5; esc = false; continue;
                }

                // kh√¥ng h·ª£p l·ªá ‚Üí b·ªè backslash, gi·ªØ k√Ω t·ª±
                out += n;
                i++; esc = false;
            }
            return out;
        }
        function autoFixJson(src) {
            let s = src.trim();

            // 1Ô∏è‚É£ N·∫øu kh√¥ng c√≥ { ho·∫∑c [ ·ªü ƒë·∫ßu ‚Üí ƒëo√°n l√† object
            if (!s.startsWith('{') && !s.startsWith('[')) {
                s = '{' + s;
            }

            // 2Ô∏è‚É£ N·∫øu kh√¥ng c√≥ } ho·∫∑c ] ·ªü cu·ªëi ‚Üí ƒëo√°n l√† object
            if (!s.endsWith('}') && !s.endsWith(']')) {
                s = s + '}';
            }

            // 3Ô∏è‚É£ V√° ngo·∫∑c th·ª´a/th·ª•t: n·∫øu s·ªë { ‚â† s·ªë }
            const openBraces = (s.match(/{/g) || []).length;
            const closeBraces = (s.match(/}/g) || []).length;
            const openBrackets = (s.match(/\[/g) || []).length;
            const closeBrackets = (s.match(/]/g) || []).length;

            if (openBraces > closeBraces) {
                s += '}'.repeat(openBraces - closeBraces);
            } else if (openBraces < closeBraces) {
                s = '{'.repeat(closeBraces - openBraces) + s;
            }

            if (openBrackets > closeBrackets) {
                s += ']'.repeat(openBrackets - closeBrackets);
            } else if (openBrackets < closeBrackets) {
                s = '['.repeat(closeBrackets - openBrackets) + s;
            }

            // 4Ô∏è‚É£ N·∫øu b·ªã thi·∫øu d·∫•u ph·∫©y gi·ªØa c√°c key-value (nh∆∞ng t·∫°m ƒë·ªÉ an to√†n)
            s = s.replace(/}(\s*){/g, '},$1{');
            s = s.replace(/"(\s*)"(\s*):/g, '"$1",$2:'); // v√° l·ªói chu·ªói b·ªã n·ªëi li·ªÅn

            return s;
        }
        function quoteRegexLiterals(src) {
            let out = '';
            let i = 0;
            let inStr = false, esc = false;

            while (i < src.length) {
                const ch = src[i];
                const nxt = src[i + 1];

                // trong string "..."
                if (inStr) {
                    out += ch;
                    if (esc) esc = false;
                    else if (ch === '\\') esc = true;
                    else if (ch === '"') inStr = false;
                    i++;
                    continue;
                }

                // m·ªü string
                if (ch === '"') {
                    inStr = true;
                    out += ch;
                    i++;
                    continue;
                }

                // g·∫∑p regex literal b·∫Øt ƒë·∫ßu b·∫±ng /.../flags (kh√¥ng ph·∫£i comment)
                if (ch === '/' && nxt !== '/' && nxt !== '*') {
                    const start = i;
                    i++; // skip '/'

                    let inClass = false; // inside [...]
                    let escaped = false;

                    while (i < src.length) {
                        const c = src[i];

                        if (escaped) {
                            escaped = false;
                            i++;
                            continue;
                        }
                        if (c === '\\') {
                            escaped = true;
                            i++;
                            continue;
                        }
                        if (c === '[') inClass = true;
                        if (c === ']') inClass = false;

                        // k·∫øt th√∫c regex khi g·∫∑p '/' ngo√†i char class
                        if (c === '/' && !inClass) {
                            i++; // include closing '/'
                            break;
                        }
                        i++;
                    }

                    // ƒë·ªçc flags (gimsyu d...)
                    while (i < src.length && /[a-z]/i.test(src[i])) i++;

                    const literal = src.slice(start, i); // v√≠ d·ª•: /[ƒë]/g

                    // bi·∫øn th√†nh string JSON h·ª£p l·ªá
                    const jsonStr = '"' + literal
                        .replace(/\\/g, '\\\\')
                        .replace(/"/g, '\\"') + '"';

                    out += jsonStr;
                    continue;
                }

                out += ch;
                i++;
            }

            return out;
        }
        function fixSingleQuotes(src) {
            let out = '';
            let inDouble = false;
            let inSingle = false;
            let esc = false;

            for (let i = 0; i < src.length; i++) {
                const ch = src[i];

                // ƒëang trong chu·ªói double quote
                if (inDouble) {
                    out += ch;
                    if (!esc && ch === '\\') esc = true;
                    else if (!esc && ch === '"') inDouble = false;
                    else esc = false;
                    continue;
                }

                // ƒëang trong chu·ªói single quote
                if (inSingle) {
                    if (ch === "'" && !esc) {
                        out += '"';
                        inSingle = false;
                    } else {
                        if (ch === '\\' && !esc) esc = true;
                        else esc = false;
                        out += ch;
                    }
                    continue;
                }

                // ngo√†i chu·ªói
                if (ch === "'") {
                    // n·∫øu l√† chu·ªói m·ªü
                    out += '"';
                    inSingle = true;
                    continue;
                }

                out += ch;
            }

            return out;
        }
        function normalizeJson(raw) {
            let s = autoFixJson(raw); // t·ª± ƒë·ªông v√° ngo·∫∑c n·∫øu thi·∫øu
            s = stripComments(s);
            s = quoteRegexLiterals(s);
            s = stripTrailingCommas(s);
            s = fixSingleQuotes(s);
            s = replaceUndefined(s);
            s = handleEllipsis(s);
            s = quoteKeysAndExpandShorthand(s);
            s = fixInvalidEscapes(s);
            return s;
        }

        /* ===== Sort all fields alphabetically ===== */
        function sortKeysAlphabetically(obj) {
            if (Array.isArray(obj)) {
                // Duy·ªát t·ª´ng ph·∫ßn t·ª≠ trong m·∫£ng
                return obj.map(sortKeysAlphabetically);
            } else if (obj && typeof obj === 'object' && obj.constructor === Object) {
                // Object b√¨nh th∆∞·ªùng ‚Üí s·∫Øp x·∫øp key
                const sorted = {};
                Object.keys(obj).sort((a, b) => a.localeCompare(b)).forEach(k => {
                    sorted[k] = sortKeysAlphabetically(obj[k]);
                });
                return sorted;
            } else {
                // Gi√° tr·ªã nguy√™n th·ªßy (string, number, null,...)
                return obj;
            }
        }

        /* ===== Tree rendering ===== */
        let lockedLine = null, lockedNode = null;
        function buildTree(value, key = null, depth = 0) {
            const node = document.createElement('div'); node.className = 'node' + (depth === 0 ? ' root' : '');
            const t = typeOf(value), isContainer = (t === 'object' || t === 'array');
            const childCount = isContainer ? (t === 'array' ? value.length : Object.keys(value).length) : 0;

            const line = document.createElement('div'); line.className = 'line';
            const caret = document.createElement('span'); caret.className = 'caret' + (isContainer ? '' : ' disabled'); caret.textContent = isContainer ? '‚àí' : ''; caret.setAttribute('aria-label', isContainer ? 'Collapse' : 'Leaf');

            const label = document.createElement('span'); label.className = 'label';
            label.innerHTML =
                (key !== null
                    ? `<span class="key" data-key="${escapeHtml(key)}">"${escapeHtml(key)}"</span>: `
                    : ''
                )
                + (isContainer
                    ? `<span class="type">${t}${t === 'array' ? `[${childCount}]` : `{${childCount}}`}</span>`
                    : renderScalar(value)
                );

            if (isContainer) { line._childKeys = (t === 'array' ? value.map((_, i) => String(i)) : Object.keys(value).map(String)); line._nodeType = t; } else { line._childKeys = []; line._nodeType = 'leaf'; }

            line.appendChild(caret); line.appendChild(label); node.appendChild(line);

            if (isContainer) {
                const children = document.createElement('div'); children.className = 'children';
                const entries = (t === 'array' ? value.map((v, i) => [i, v]) : Object.entries(value));
                for (const [k, v] of entries) children.appendChild(buildTree(v, k, depth + 1));
                node.appendChild(children);
                caret.onclick = (ev) => { ev.stopPropagation(); const c = children.classList.toggle('hidden'); caret.textContent = c ? '+' : '‚àí'; caret.setAttribute('aria-label', c ? 'Expand' : 'Collapse'); };
            }
            return node;
        }
        function renderScalar(v) {
            const t = typeOf(v);
            if (t === 'string') return `<span class="val-str">"${escapeHtml(v)}"</span>`;
            if (t === 'number') return `<span class="val-num">${v}</span>`;
            if (t === 'boolean') return `<span class="val-bool">${v}</span>`;
            if (t === 'null') return `<span class="val-null">null</span>`;
            return `<span>${escapeHtml(String(v))}</span>`;
        }

        /* ===== Analyze + UI ===== */
        let unquoteKeys = false;
        function removeQuotesFromKeys(txt) { return txt.replace(/^(\s*)"(.*?)"\s*:(\s)/gm, '$1$2:$3'); }
        function updateQuotesBtn() { $('#btnToggleQuotes').textContent = unquoteKeys ? 'üî§ Gi·ªØ " " field' : 'üî§ B·ªè " " field'; }

        function analyze() {
            tree.innerHTML = ''; pretty.textContent = ''; setPill(err, ''); setPill(rc, ''); setPill(childInfo, '');
            if (lockedLine) { lockedLine.classList.remove('selected'); lockedLine = null; }
            if (lockedNode) { lockedNode.classList.remove('selected-subtree'); lockedNode = null; }

            const raw = input.value.trim(); if (!raw) { meta.textContent = ''; refreshStats(null); refreshLists(null); return; }

            let data;
            try { data = JSON.parse(normalizeJson(raw)); }
            catch (e) { setPill(err, `‚ùå JSON kh√¥ng h·ª£p l·ªá: ${e.message}`); meta.textContent = ''; refreshStats(null); refreshLists(null); return; }

            tree.appendChild(buildTree(data));
            const base = JSON.stringify(data, null, 2);
            pretty.textContent = unquoteKeys ? removeQuotesFromKeys(base) : base;

            const sizeBytes = new Blob([raw]).size;
            meta.textContent = `K√Ω t·ª±: ${raw.length.toLocaleString()} ‚Ä¢ Minified: ${JSON.stringify(data).length.toLocaleString()} ‚Ä¢ K√≠ch th∆∞·ªõc ~${sizeBytes.toLocaleString()} B`;

            if (search.value.trim()) applySearch(); toggleClearSearch();
            isCollapsedView = false; updateToggleBtn();

            const stats = computeStats(data, raw.length, sizeBytes);
            refreshStats(stats);
            const extraction = extractData(data);
            refreshLists(extraction);
        }
        function clearMarks(el) {
            el.querySelectorAll('mark.mark').forEach(m => {
                // thay mark b·∫±ng text node thu·∫ßn
                const textNode = document.createTextNode(m.textContent);
                m.replaceWith(textNode);
            });

            // g·ªôp text node li·ªÅn k·ªÅ (tr√°nh b·ªã c·∫Øt nh·ªè ra)
            el.normalize();
        }
        function highlightText(el, re) {
            // T·∫°o regex m·ªõi cho node hi·ªán t·∫°i (kh√¥ng reuse re c√≥ lastIndex)
            const reLocal = new RegExp(re.source, re.flags);

            const walker = document.createNodeIterator(el, NodeFilter.SHOW_TEXT, null);
            const texts = [];
            for (let n; (n = walker.nextNode());) texts.push(n);

            texts.forEach(node => {
                const s = node.nodeValue;
                if (!s) return;

                // Reset tr∆∞·ªõc khi d√πng
                reLocal.lastIndex = 0;
                if (!reLocal.test(s)) return;
                reLocal.lastIndex = 0;

                const frag = document.createDocumentFragment();
                let last = 0, m;
                while ((m = reLocal.exec(s))) {
                    if (m.index > last) {
                        frag.appendChild(document.createTextNode(s.slice(last, m.index)));
                    }
                    const mark = document.createElement('mark');
                    mark.className = 'mark';
                    mark.textContent = m[0];
                    frag.appendChild(mark);
                    last = m.index + m[0].length;
                }
                if (last < s.length) {
                    frag.appendChild(document.createTextNode(s.slice(last)));
                }
                node.parentNode.replaceChild(frag, node);
            });
        }

        /* ===== Search ===== */
        function applySearch() {
            const q = search.value.trim();
            const lines = tree.querySelectorAll('.node .line');

            // 1) d·ªçn highlight c≈©
            lines.forEach(n => {
                n.classList.remove('hit', 'hit-focus');
                const label = n.querySelector('.label');
                if (label) clearMarks(label);
            });

            // reset k·∫øt qu·∫£
            searchHits = [];
            currentHitIndex = -1;
            setPill(rc, '');
            updateNavButtons(); // ·∫©n n√∫t ‚Üê ‚Üí

            if (!q) return;

            // 2) chu·∫©n b·ªã regex: t·∫°o m·ªõi m·ªói l·∫ßn g√µ
            let flags = searchFlags.case ? 'g' : 'gi';
            let reTest, reHL;

            if (searchFlags.regex) {
                try {
                    reTest = new RegExp(q, searchFlags.case ? '' : 'i');
                    reHL = new RegExp(q, flags);
                } catch {
                    return;
                }
            } else {
                const safe = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                let pattern = searchFlags.whole
                    ? `(?<![A-Za-z0-9_-])${safe}(?![A-Za-z0-9_-])`
                    : safe;

                reTest = new RegExp(pattern, searchFlags.case ? '' : 'i');
                reHL = new RegExp(pattern, flags);
            }

            // 3) x·ª≠ l√Ω special case [] ho·∫∑c {}
            if (q === '[]' || q === '{}') {
                const want = (q === '[]') ? 'array' : 'object';
                lines.forEach(line => {
                    if (line._nodeType === want &&
                        Array.isArray(line._childKeys) &&
                        line._childKeys.length === 0) {

                        line.classList.add('hit');
                        const t = line.querySelector('.type');
                        if (t) t.innerHTML = `<mark class="mark">${t.textContent}</mark>`;
                        openParentsOfLine(line);
                        searchHits.push(line);
                    }
                });
                setPill(rc, `K·∫øt qu·∫£: ${searchHits.length}${searchHits.length ? ` (1/${searchHits.length})` : ''}`);
                updateNavButtons();
                if (searchHits.length) focusHit(0, true);
                return;
            }

            // 4) qu√©t & highlight an to√†n (ch·ªâ text node con)
            let count = 0;
            lines.forEach(line => {
                const label = line.querySelector('.label');
                const keyText = label?.querySelector('.key')?.textContent || '';
                const valueText =
                    label?.querySelector('.val-str, .val-num, .val-bool, .val-null')?.textContent || '';

                const haystack = keyText + ' ' + valueText;

                let ok = false;
                if (reTest) {
                    // T·∫°o regex clone b·ªè c·ªù g ƒë·ªÉ tr√°nh bug lastIndex
                    const reCheck = new RegExp(reTest.source, reTest.flags.replace('g', ''));
                    ok = reCheck.test(haystack);
                } else {
                    ok = haystack.toLowerCase().includes(q.toLowerCase());
                }
                if (!ok) return;

                count++;
                line.classList.add('hit');

                if (label && reHL) {
                    const targets = label.querySelectorAll('.key, .val-str, .val-num, .val-bool, .val-null');
                    targets.forEach(el => highlightText(el, reHL));
                }

                openParentsOfLine(line);
                searchHits.push(line);
            });

            // 5) c·∫≠p nh·∫≠t ƒë·∫øm + focus k·∫øt qu·∫£ ƒë·∫ßu ti√™n
            setPill(rc, `K·∫øt qu·∫£: ${count}${count ? ` (1/${count})` : ''}`);
            updateNavButtons();
            if (searchHits.length) focusHit(0, true);
            updateFloatingNav();
        }

        function updateNavButtons() {
            const box = $('#navHits');
            if (!box) return;
            const has = searchHits.length > 0;
            box.style.display = has ? 'flex' : 'none';
            if (has) {
                setPill(rc, `K·∫øt qu·∫£: ${searchHits.length} (${currentHitIndex + 1}/${searchHits.length})`);
            } else {
                setPill(rc, '');
            }
        }
        function focusHit(i, smooth = false) {
            if (i < 0 || i >= searchHits.length) return;
            tree.querySelectorAll('.hit-focus').forEach(n => n.classList.remove('hit-focus'));
            const line = searchHits[i];
            openParentsOfLine(line);
            line.classList.add('hit-focus');
            line.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'center' });
            currentHitIndex = i;
            setPill(rc, `K·∫øt qu·∫£: ${searchHits.length} (${currentHitIndex + 1}/${searchHits.length})`);
            updateFloatingNav();
        }
        function openParentsOfLine(line) {
            // B·∫£o ƒë·∫£m node hi·ªán t·∫°i v√† to√†n b·ªô ancestor ƒë∆∞·ª£c expand
            let node = line.closest('.node');
            while (node) {
                const parent = node.parentElement?.closest('.node');
                if (!parent) break; // t·ªõi g·ªëc

                const children = parent.querySelector(':scope > .children');
                const caret = parent.querySelector(':scope > .line > .caret');

                if (children && children.classList.contains('hidden')) {
                    children.classList.remove('hidden');
                    if (caret) caret.textContent = '‚àí';
                }
                node = parent;
            }
        }

        // ===== Floating search nav (Option B) =====
        const searchFloat = document.getElementById('searchFloat');
        const floatPrev = document.getElementById('floatPrev');
        const floatNext = document.getElementById('floatNext');
        const floatCounter = document.getElementById('floatCounter');
        const optCase2 = document.getElementById('optCase2');
        const optWhole2 = document.getElementById('optWhole2');

        function isElementInViewport(el) {
            if (!el) return true;
            const r = el.getBoundingClientRect();
            return r.bottom > 0 && r.top < window.innerHeight;
        }

        function updateFloatingNav() {
            if (!searchFloat) return;

            const bar = document.getElementById('resultSearchBar'); // ‚úÖ thanh search ngang
            const barVisible = isElementInViewport(bar);

            // ‚úÖ ch·ªâ hi·ªán khi: c√≥ keyword + thanh search ngang kh√¥ng c√≤n nh√¨n th·∫•y
            const show = !barVisible;

            searchFloat.style.display = show ? 'grid' : 'none';
            searchFloat.setAttribute('aria-hidden', show ? 'false' : 'true');

            if (!show) return;

            // sync text input (khi user search ·ªü thanh ngang)
            if (search2 && search2.value !== search.value) {
                search2.value = search.value;
                toggleClearSearch2();
            }

            // sync option state
            syncSearchUIFromFlags();

            // Counter
            if (floatCounter) {
                const has = searchHits.length > 0;
                const cur = has ? (currentHitIndex + 1) : 0;
                floatCounter.textContent = `${cur}/${searchHits.length}`;
            }
        }

        // Bind n√∫t ƒëi·ªÅu h∆∞·ªõng d·ªçc
        if (!window.__floatNavBound) {
            floatNext?.addEventListener('click', () => {
                if (!searchHits.length) return;
                const next = (currentHitIndex + 1) % searchHits.length;
                focusHit(next, true);
                updateFloatingNav();
            });

            floatPrev?.addEventListener('click', () => {
                if (!searchHits.length) return;
                const prev = (currentHitIndex - 1 + searchHits.length) % searchHits.length;
                focusHit(prev, true);
                updateFloatingNav();
            });

            window.__floatNavBound = true;
        }

        // Khi scroll/resize th√¨ ki·ªÉm tra l·∫°i
        window.addEventListener('scroll', () => updateFloatingNav(), { passive: true });
        window.addEventListener('resize', () => updateFloatingNav());

        function syncSearchUIFromFlags() {
            // sync n√∫t optCase/optWhole c·ªßa thanh ngang (ƒëang c√≥) + thanh d·ªçc (m·ªõi)
            const a1 = document.getElementById('optCase');
            const w1 = document.getElementById('optWhole');

            const setBtn = (btn, on, textOn, textOff, titleOn, titleOff) => {
                if (!btn) return;
                btn.classList.toggle('active', !!on);
                btn.textContent = on ? textOn : textOff;
                btn.title = on ? titleOn : titleOff;
            };

            setBtn(a1, searchFlags.case, 'Aa*', 'Aa', 'Ph√¢n bi·ªát HOA/th∆∞·ªùng', 'Kh√¥ng ph√¢n bi·ªát HOA/th∆∞·ªùng');
            setBtn(optCase2, searchFlags.case, 'Aa*', 'Aa', 'Ph√¢n bi·ªát HOA/th∆∞·ªùng', 'Kh√¥ng ph√¢n bi·ªát HOA/th∆∞·ªùng');

            setBtn(w1, searchFlags.whole, 'üîç*', 'üîç', 'T√¨m ch√≠nh x√°c', 'T√¨m kh√¥ng ch√≠nh x√°c');
            setBtn(optWhole2, searchFlags.whole, 'üîç*', 'üîç', 'T√¨m ch√≠nh x√°c', 'T√¨m kh√¥ng ch√≠nh x√°c');
        }

        search2?.addEventListener('input', () => {
            // sync value sang thanh ngang (ngu·ªìn d·ªØ li·ªáu th·∫≠t l√† #search)
            search.value = search2.value;
            toggleClearSearch();
            toggleClearSearch2();

            // debounce ƒë·ªÉ kh√¥ng b·ªã ‚Äúnh·∫£y‚Äù khi m·ªõi g√µ ‚Äúnam‚Äù
            debouncedApplySearch();
        });

        search2?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                search.value = search2.value;
                toggleClearSearch();
                toggleClearSearch2();
                applySearch();
                updateFloatingNav();
            }
        });

        btnClearSearch2?.addEventListener('click', () => {
            search.value = '';
            search2.value = '';
            toggleClearSearch();
            toggleClearSearch2();
            applySearch();
            updateFloatingNav();
            search2.focus({ preventScroll: true });
        });

        optCase2?.addEventListener('click', () => {
            searchFlags.case = !searchFlags.case;
            syncSearchUIFromFlags();
            applySearch();
            updateFloatingNav();
        });

        optWhole2?.addEventListener('click', () => {
            searchFlags.whole = !searchFlags.whole;
            syncSearchUIFromFlags();
            applySearch();
            updateFloatingNav();
        });

        const floatHandle = document.getElementById('floatHandle');

        function floatExpand() {
            if (!searchFloat) return;
            searchFloat.classList.remove('is-collapsed');
            searchFloat.classList.add('is-expanded');
        }

        function floatCollapse() {
            if (!searchFloat) return;
            // n·∫øu ƒëang focus input th√¨ kh√¥ng collapse
            if (document.activeElement === search2) return;
            searchFloat.classList.remove('is-expanded');
            searchFloat.classList.add('is-collapsed');
        }

        // hover ƒë·ªÉ m·ªü
        searchFloat?.addEventListener('mouseenter', floatExpand);
        searchFloat?.addEventListener('mouseleave', floatCollapse);

        // click icon ƒë·ªÉ toggle
        floatHandle?.addEventListener('click', () => {
            const expanded = searchFloat.classList.contains('is-expanded');
            if (expanded) floatCollapse();
            else {
                floatExpand();
                search2?.focus({ preventScroll: true });
            }
        });

        // focus v√†o input th√¨ m·ªü
        search2?.addEventListener('focus', floatExpand);
        // blur input th√¨ thu l·∫°i
        search2?.addEventListener('blur', () => {
            // delay nh·ªè ƒë·ªÉ click n√∫t ‚Üë‚Üì kh√¥ng b·ªã collapse ngay
            setTimeout(floatCollapse, 120);
        });

        /* Hover & lock child-count */
        function updateChildCount(line) { if (!line) { setPill(childInfo, ''); return; } const n = Array.isArray(line._childKeys) ? line._childKeys.length : 0; setPill(childInfo, `Con tr·ª±c ti·∫øp: ${n}`); }
        tree.addEventListener('mouseover', e => { if (lockedLine) return; const line = e.target.closest('.line'); if (!line || !tree.contains(line)) return; updateChildCount(line); });
        tree.addEventListener('click', e => {
            const keyEl = e.target.closest('.key'); if (!keyEl) return;
            const line = keyEl.closest('.line'); if (!line || !tree.contains(line)) return; if (line._nodeType === 'leaf') return;
            const node = line.parentElement;
            if (lockedLine === line) { line.classList.remove('selected'); node.classList.remove('selected-subtree'); lockedLine = null; lockedNode = null; setPill(childInfo, ''); }
            else {
                if (lockedLine) lockedLine.classList.remove('selected'); if (lockedNode) lockedNode.classList.remove('selected-subtree');
                lockedLine = line; lockedNode = node; line.classList.add('selected'); node.classList.add('selected-subtree'); updateChildCount(line);
            }
        });
        window.addEventListener('keydown', e => { if (e.key === 'Escape' && lockedLine) { lockedLine.classList.remove('selected'); lockedLine = null; if (lockedNode) { lockedNode.classList.remove('selected-subtree'); lockedNode = null; } setPill(childInfo, ''); } });

        /* Collapse/Expand all (gi·ªØ c·∫•p 1 khi collapse) */
        let isCollapsedView = false;
        function updateToggleBtn() { const btn = $('#btnToggleAll'); if (btn) btn.textContent = isCollapsedView ? '‚§¢ Expand all' : '‚§° Collapse all'; }
        function expandAll() { const nodes = tree.querySelectorAll('.node'); nodes.forEach(n => { const c = n.querySelector(':scope > .children'); const caret = n.querySelector(':scope > .line > .caret'); if (!c || !caret) return; c.classList.remove('hidden'); caret.textContent = '‚àí'; }); }
        function collapseToTopLevel() { const rootChildren = tree.querySelector('.node.root > .children'); if (rootChildren) rootChildren.classList.remove('hidden'); const nodes = tree.querySelectorAll('.node:not(.root)'); nodes.forEach(n => { const c = n.querySelector(':scope > .children'); const caret = n.querySelector(':scope > .line > .caret'); if (!c || !caret) return; c.classList.add('hidden'); caret.textContent = '+'; }); }
        $('#btnToggleAll').addEventListener('click', () => { if (isCollapsedView) { expandAll(); isCollapsedView = false; } else { collapseToTopLevel(); isCollapsedView = true; } updateToggleBtn(); });

        /* ===== Stats / Extraction ===== */
        function computeStats(data, charLen, sizeBytes) {
            let keys = 0, obj = 0, arr = 0, elems = 0, depth = 0, s = 0, n = 0, b = 0, nu = 0;
            (function walk(v, d) {
                depth = Math.max(depth, d);
                const t = typeOf(v);
                if (t === 'object') { obj++; const ks = Object.keys(v); keys += ks.length; elems++; if (ks.length === 0) nu++; ks.forEach(k => walk(v[k], d + 1)); }
                else if (t === 'array') { arr++; elems++; if (v.length === 0) nu++; v.forEach(x => walk(x, d + 1)); }
                else {
                    elems++;
                    if (t === 'string') {
                        // chu·ªói r·ªóng t√≠nh v√†o null
                        if (v === '') nu++; else s++;
                    } else if (t === 'number') n++;
                    else if (t === 'boolean') b++;
                    else if (t === 'null') nu++;
                }
            })(data, 1);
            return { keys, obj, arr, elems, depth, sizeBytes, counts: { string: s, number: n, boolean: b, null: nu } };
        }
        function refreshStats(st) {
            statsPills.innerHTML = '';
            if (!st) { keysList.innerHTML = ''; return };
            const add = (txt) => { const span = document.createElement('span'); span.className = 'pill'; span.textContent = txt; statsPills.appendChild(span); }
            add(`T·ªïng kh√≥a: ${st.keys.toLocaleString()}`);
            add(`Objects: ${st.obj.toLocaleString()}`);
            add(`Arrays: ${st.arr.toLocaleString()}`);
            add(`Ph·∫ßn t·ª≠: ${st.elems.toLocaleString()}`);
            add(`ƒê·ªô s√¢u t·ªëi ƒëa: ${st.depth}`);
            add(`K√≠ch th∆∞·ªõc: ~${st.sizeBytes.toLocaleString()} B`);
            add(`string: ${st.counts.string}`);
            add(`number: ${st.counts.number}`);
            add(`boolean: ${st.counts.boolean}`);
            add(`null: ${st.counts.null}`);
        }
        function extractData(data) {
            const keyMap = new Map();

            // Map cho unique + ƒë·∫øm
            const uniq = {
                string: new Map(),  // value -> count
                number: new Map(),
                boolean: new Map(),  // "true"/"false" -> count
                null: new Map()   // "null" | "(empty)" -> count
            };
            const totals = { stringTotal: 0, numberTotal: 0, booleanTotal: 0, nullTotal: 0 };

            const add = (map, key) => map.set(key, (map.get(key) || 0) + 1);

            (function walk(v) {
                const t = typeOf(v);

                if (t === 'object') {
                    const ks = Object.keys(v);
                    if (ks.length === 0) {                 // {} ‚Üí t√≠nh nh∆∞ null
                        totals.nullTotal++;
                        add(uniq.null, '(empty-object)');
                    }
                    ks.forEach(k => {                      // v·∫´n duy·ªát ti·∫øp c√°c gi√° tr·ªã con
                        keyMap.set(k, (keyMap.get(k) || 0) + 1);
                        walk(v[k]);
                    });

                } else if (t === 'array') {
                    if (v.length === 0) {                  // [] ‚Üí t√≠nh nh∆∞ null
                        totals.nullTotal++;
                        add(uniq.null, '(empty-array)');
                    } else {
                        v.forEach(walk);
                    }

                } else if (t === 'string') {
                    if (v === '') {                        // "" ‚Üí null
                        totals.nullTotal++;
                        add(uniq.null, '(empty)');
                    } else {
                        totals.stringTotal++;
                        add(uniq.string, v);
                    }

                } else if (t === 'number') {
                    totals.numberTotal++;
                    add(uniq.number, String(v));

                } else if (t === 'boolean') {
                    totals.booleanTotal++;
                    add(uniq.boolean, v ? 'true' : 'false');

                } else if (t === 'null') {
                    totals.nullTotal++;
                    add(uniq.null, 'null');
                }
            })(data);

            // Map -> m·∫£ng [value,count], sort nh·∫π
            const listify = (m, num = false) =>
                Array.from(m.entries())
                    .sort((a, b) => num ? (Number(a[0]) - Number(b[0])) : a[0].localeCompare(b[0]));

            return {
                keys: Array.from(keyMap.entries()).sort((a, b) => b[1] - a[1]),  // sort theo s·ªë l·∫ßn
                uniques: {
                    string: listify(uniq.string),
                    number: listify(uniq.number, true),
                    boolean: listify(uniq.boolean),
                    null: listify(uniq.null)
                },
                totals
            };
        }
        function refreshLists(ex) {
            // clear
            [listStrings, listNumbers, listBooleans, listNulls].forEach(el => el && (el.innerHTML = ''));
            if (!ex) {
                // Reset headers if no valid data is provided
                $('#headBool').textContent = `Boolean (t·ªïng 0)`;
                $('#headNull').textContent = `Null (t·ªïng 0)`;
                $('#headString').textContent = `String (t·ªïng 0)`;
                $('#headNumber').textContent = `Number (t·ªïng 0)`;
                return;
            }

            // C·∫≠p nh·∫≠t ti√™u ƒë·ªÅ: t·ªïng (kh√¥ng ph·∫£i s·ªë unique)
            $('#headBool').textContent = `Boolean (t·ªïng ${ex.totals.booleanTotal})`;
            $('#headNull').textContent = `Null (t·ªïng ${ex.totals.nullTotal})`;
            $('#headString').textContent = `String (t·ªïng ${ex.totals.stringTotal})`;
            $('#headNumber').textContent = `Number (t·ªïng ${ex.totals.numberTotal})`;

            // ---- Boolean/Null: hi·ªÉn th·ªã unique l√†m TAG, k√®m ƒë·∫øm ----
            const mkTags = (arr, cls) => arr.map(([v, c]) =>
                `<span class="tag ${cls}" data-q="${v}">${v}<span class="small">√ó${c}</span></span>`
            ).join('');

            listBooleans.innerHTML = mkTags(ex.uniques.boolean, 'boolean');
            listNulls.innerHTML = mkTags(ex.uniques.null, 'null');

            // ---- String/Number: danh s√°ch duy nh·∫•t (k√®m ƒë·∫øm) ----
            const mkLines = (arr, cls) => arr.map(([v, c]) =>
                `<span class="val-item ${cls}" title="${escapeHtml(v)}" data-q="${escapeHtml(v)}">${escapeHtml(v)} <span class="small">√ó${c}</span></span>`
            ).join('');

            listStrings.innerHTML = mkLines(ex.uniques.string, 'string');
            listNumbers.innerHTML = mkLines(ex.uniques.number, 'number');

            // Click -> ƒë·∫©y v√†o √¥ search + ch·∫°y highlight
            const wireClick = (root) => root.addEventListener('click', (e) => {
                const x = e.target.closest('[data-q]'); if (!x) return;
                let q = x.getAttribute('data-q');
                // map (empty) -> "" ƒë·ªÉ kh·ªõp hi·ªÉn th·ªã trong c√¢y
                if (q === '(empty)') q = '""';
                else if (q === '(empty-array)') q = '[]';      // ‚¨ÖÔ∏è
                else if (q === '(empty-object)') q = '{}';
                search.value = q;
                toggleClearSearch();
                applySearch();
                search.focus({ preventScroll: true });
            });

            keysList.innerHTML = ex.keys
                .map(([k, c]) => {
                    return `<span class="pill key-pill" data-key="${escapeHtml(k)}">
              ${escapeHtml(k)} <span class="small">√ó${c}</span>
            </span>`;
                })
                .join('');

            keysList.onclick = (e) => {
                const it = e.target.closest('.pill');
                if (!it) return;

                search.value = it.dataset.key;

                // B·∫≠t flag whole-match khi click t·ª´ keysList
                searchFlags.whole = true;
                document.getElementById('optWhole').classList.add('active');
                document.getElementById('optWhole').textContent = 'üîç*';
                document.getElementById('optWhole').title = 'T√¨m ki·∫øm ch√≠nh x√°c';

                toggleClearSearch();
                applySearch();
                search.focus({ preventScroll: true });
            };

            [listBooleans, listNulls, listStrings, listNumbers].forEach(el => wireClick(el));
        }
        function resetSearchFlags() {
            searchFlags = { case: false, whole: false };
            const optCase = document.getElementById('optCase');
            const optWhole = document.getElementById('optWhole');

            optCase.classList.remove('active');
            optCase.textContent = 'Aa';
            optCase.title = 'Kh√¥ng ph√¢n bi·ªát HOA/th∆∞·ªùng';

            optWhole.classList.remove('active');
            optWhole.textContent = 'üîç';
            optWhole.title = 'T√¨m ki·∫øm kh√¥ng ch√≠nh x√°c';

            syncSearchUIFromFlags();
        }

        /* ===== Events ===== */
        const debouncedAnalyze = debounce(() => {
            // reset tr·∫°ng th√°i sort m·ªói khi nh·∫≠p m·ªõi
            sortState = 0;
            updateSortButtonLabel();
            analyze();
        }, 200);
        input.addEventListener('input', debouncedAnalyze);
        $('#btnCopy').addEventListener('click', () => { if (!pretty.textContent) return; copyText(pretty.textContent); setPill(err, '‚úÖ ƒê√£ copy JSON.'); setTimeout(() => setPill(err, ''), 1500); });
        $('#btnDownload').addEventListener('click', () => { const txt = pretty.textContent || input.value; const blob = new Blob([txt], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'data.json'; a.click(); URL.revokeObjectURL(a.href); });
        $('#btnClear').addEventListener('click', () => {
            input.value = ''; tree.innerHTML = ''; pretty.textContent = ''; setPill(err, ''); meta.textContent = ''; search.value = ''; resetSearchFlags(); toggleClearSearch(); setPill(rc, ''); setPill(childInfo, ''); refreshStats(null); refreshLists(null);
        });
        let sortState = 0; // 0: original, 1: A-Z, 2: Z-A
        let originalJson = null;

        function sortKeysRecursively(obj, order = 'asc') {
            if (Array.isArray(obj)) {
                return obj.map(item => sortKeysRecursively(item, order));
            } else if (obj && typeof obj === 'object' && obj.constructor === Object) {
                const keys = Object.keys(obj).sort((a, b) =>
                    order === 'asc' ? a.localeCompare(b) : b.localeCompare(a)
                );
                const result = {};
                keys.forEach(k => (result[k] = sortKeysRecursively(obj[k], order)));
                return result;
            }
            return obj;
        }

        function updateSortButtonLabel() {
            const btn = $('#btnSortAZ');
            if (!btn) return;
            if (sortState === 0) {
                btn.textContent = 'üî† Sort A‚ÄìZ';
                btn.title = 'Nh·∫•n ƒë·ªÉ s·∫Øp x·∫øp A ‚Üí Z';
            } else if (sortState === 1) {
                btn.textContent = 'üî° Sort Z‚ÄìA';
                btn.title = 'Nh·∫•n ƒë·ªÉ s·∫Øp x·∫øp Z ‚Üí A';
            } else {
                btn.textContent = '‚Ü©Ô∏è Restore';
                btn.title = 'Nh·∫•n ƒë·ªÉ kh√¥i ph·ª•c d·ªØ li·ªáu g·ªëc';
            }
        }

        $('#btnSortAZ').addEventListener('click', () => {
            try {
                const raw = input.value.trim();
                if (!raw) return;

                // parse JSON g·ªëc t·ª´ textarea
                let data = JSON.parse(normalizeJson(raw));

                if (sortState === 0) {
                    // 1Ô∏è‚É£ l·∫ßn ƒë·∫ßu: A ‚Üí Z
                    originalJson = data; // l∆∞u object g·ªëc
                    data = sortKeysRecursively(data, 'asc');
                    sortState = 1;
                } else if (sortState === 1) {
                    // 2Ô∏è‚É£ l·∫ßn hai: Z ‚Üí A
                    data = sortKeysRecursively(data, 'desc');
                    sortState = 2;
                } else {
                    // 3Ô∏è‚É£ l·∫ßn ba: quay l·∫°i b·∫£n g·ªëc
                    if (originalJson) {
                        data = originalJson;
                        sortState = 0;
                    } else {
                        return;
                    }
                }

                // render ra c√¢y k·∫øt qu·∫£ m√† KH√îNG thay ƒë·ªïi input
                tree.innerHTML = '';
                tree.appendChild(buildTree(data));

                const base = JSON.stringify(data, null, 2);
                pretty.textContent = unquoteKeys ? removeQuotesFromKeys(base) : base;

                updateSortButtonLabel();
                setTimeout(() => setPill(err, ''), 2000);
            } catch (e) {
                setPill(err, '‚ùå JSON kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng th·ªÉ s·∫Øp x·∫øp.');
                console.error(e);
            }
        });
        updateSortButtonLabel();
        $('#btnSample').addEventListener('click', () => { input.value = '{ "field-1": "value-1", "field-2": 200, "array-1": [ { "array-field-1": "a", "array-field-2": 1 }, { "array-field-1": "b", "array-field-2": 2 }, { "array-field-1": "c", "array-field-2": 3, "emptyArr": [], "emptyObj": {} } ], "object-1": { "field-1a": true, "field-1b": null, "emptyArr": [], "emptyObj": {}, "nested": { "deeperEmptyArr": [], "deeperEmptyObj": {} } }, "emptyArrayTop": [], "emptyObjectTop": {} }'; analyze(); });
        $('#fileInput').addEventListener('change', e => { const f = e.target.files?.[0]; if (!f) return; const r = new FileReader(); r.onload = () => { input.value = String(r.result || ''); analyze(); }; r.readAsText(f); });

        function debounce(fn, wait = 1200) {
            let t = null;
            return function (...args) {
                clearTimeout(t);
                t = setTimeout(() => fn.apply(this, args), wait);
            };
        }
        const debouncedApplySearch = debounce(() => applySearch(), 300); // 1000ms = 1.0s

        search.addEventListener('input', () => { toggleClearSearch(); debouncedApplySearch(); });
        search.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                applySearch(); // ch·∫°y ngay
            }
        });
        btnClearSearch.addEventListener('click', () => {
            search.value = '';
            resetSearchFlags();
            applySearch();
            toggleClearSearch();
            updateFloatingNav();
            search.focus();
        });
        $('#btnToggleQuotes').addEventListener('click', () => { unquoteKeys = !unquoteKeys; updateQuotesBtn(); try { const data = JSON.parse(normalizeJson(input.value || '{}')); const base = JSON.stringify(data, null, 2); pretty.textContent = unquoteKeys ? removeQuotesFromKeys(base) : base; } catch { } });
        // G·∫Øn n√∫t ƒëi·ªÅu h∆∞·ªõng k·∫øt qu·∫£ T√åM KI·∫æM ch·ªâ 1 l·∫ßn
        if (!window.__navBound) {
            $('#btnNextHit')?.addEventListener('click', () => {
                if (!searchHits.length) return;
                const next = (currentHitIndex + 1) % searchHits.length;
                focusHit(next, true);
            });
            $('#btnPrevHit')?.addEventListener('click', () => {
                if (!searchHits.length) return;
                const prev = (currentHitIndex - 1 + searchHits.length) % searchHits.length;
                focusHit(prev, true);
            });
            window.__navBound = true;
        }

        let searchFlags = { case: false, whole: false };

        function toggleFlag(name, btn) {
            searchFlags[name] = !searchFlags[name];
            btn.classList.toggle('active', searchFlags[name]);
            if (name === 'case') {
                btn.textContent = searchFlags.case ? 'Aa*' : 'Aa';
                btn.title = searchFlags.case
                    ? 'Ph√¢n bi·ªát HOA/th∆∞·ªùng'
                    : 'Kh√¥ng ph√¢n bi·ªát HOA/th∆∞·ªùng';
            }
            if (name === 'whole') {
                btn.textContent = searchFlags.whole ? 'üîç*' : 'üîç';
                btn.title = searchFlags.whole
                    ? 'T√¨m ki·∫øm ch√≠nh x√°c'
                    : 'T√¨m ki·∫øm kh√¥ng ch√≠nh x√°c';
            }
            applySearch();
        }

        document.getElementById('optCase').addEventListener('click', e => toggleFlag('case', e.target));
        document.getElementById('optWhole').addEventListener('click', e => toggleFlag('whole', e.target));


        /* header height ‚Üí sticky offset */
        function updateStickyOffset() { const h = document.querySelector('header')?.offsetHeight || 0; document.documentElement.style.setProperty('--headerH', h + 'px'); }
        window.addEventListener('resize', updateStickyOffset); updateStickyOffset();
        document.body.setAttribute('data-theme', 'dark');
        btnToggleTheme.textContent = 'üåô';

        // L·∫•y ph·∫ßn t·ª≠ logo
        const logo = document.getElementById('brand');
        // Th√™m s·ª± ki·ªán click
        logo.addEventListener('click', () => {
            // Cu·ªôn trang l√™n ƒë·∫ßu
            window.scrollTo({
                top: 0,
                behavior: 'smooth' // S·ª≠ d·ª•ng smooth ƒë·ªÉ cu·ªôn m∆∞·ª£t m√†
            });
        });
        $('#fileInput').addEventListener('change', e => {
            const f = e.target.files?.[0];
            if (!f) return;
            const r = new FileReader();
            r.onload = () => {
                input.value = String(r.result || '');
                sortState = 0; // üÜï reset
                updateSortButtonLabel();
                analyze();
            };
            r.readAsText(f);
        });
        $('#btnSample').addEventListener('click', () => {
            input.value = '{ "field-1": "value-1", "field-2": 200 }';
            sortState = 0; // üÜï reset
            updateSortButtonLabel();
            analyze();
        });
        /* First render */
        updateQuotesBtn();
        analyze();
    </script>
</body>

</html>